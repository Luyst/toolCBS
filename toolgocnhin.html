<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">

    <title>M√¥ Ph·ªèng R·∫°p Chi·∫øu Phim (V7 - Final Polish)</title>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
            background: #eceff1;
            color: #37474f;
        }

        .container {
            display: flex;
            gap: 25px;
            max-width: 1400px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        .controls {
            background: white;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
            flex: 1;
            min-width: 350px;
        }

        .visualization-container {
            display: flex;
            flex: 2.5;
            flex-direction: column;
            gap: 20px;

        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 16px 0px 0px 16px;
            position: relative;
            height: 550px;
            border: 1px solid #cfd8dc;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        h3 {
            margin-top: 0;
            color: #263238;
            border-bottom: 2px solid #f0f2f5;
            padding-bottom: 15px;
            font-weight: 700;
            font-size: 1.3em;
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.75em;
            color: #546e7a;
        }



        .row-inputs>div {
            flex: 1;
        }


        .value-display {
            color: #0277bd;
            font-weight: 700;
        }

        .legend {
            font-size: 0.95em;
            color: #546e7a;
            display: flex;
            gap: 25px;
            align-items: center;
            padding: 10px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.03);
        }

        .legend span.item {
            display: flex;
            align-items: center;
        }

        .legend span.dot {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 8px;
            border-radius: 50%;
        }

        .dot-green {
            background: #00c853;
        }

        .dot-red {
            background: #d50000;
        }

        .line-dim {
            display: inline-block;
            width: 25px;
            height: 2px;
            background: #0d47a1;
            margin-right: 8px;
            position: relative;
            top: -3px;
        }

        .line-dim::after,
        .line-dim::before {
            content: '';
            position: absolute;
            height: 8px;
            width: 2px;
            background: #0d47a1;
            top: -3px;
        }

        .line-dim::before {
            left: 0;
        }

        .line-dim::after {
            right: 0;
        }

        .line-sight-top {
            display: inline-block;
            width: 25px;
            height: 2px;
            background: #b3e5fc;
            margin-right: 8px;
            border-bottom: 2px dashed #b3e5fc;
        }

        .line-sight-bot {
            display: inline-block;
            width: 25px;
            height: 2px;
            background: #00c853;
            margin-right: 8px;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="controls">
            <div class="section">
                <h3>1. Kh√¥ng Gian Ph√≤ng (cm)</h3>
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label">Chi·ªÅu d√†i</label><input class="form-control" type="number"
                            id="roomLength" value="750" min="300" max="3000">
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Chi·ªÅu r·ªông</label><input class="form-control" type="number"
                            id="roomWidth" value="640" min="200" max="2000">
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">Chi·ªÅu cao tr·∫ßn</label><input class="form-control" type="number"
                            id="roomHeight" value="340" min="200" max="2000">
                    </div>
                </div>
            </div>
            <div class="section">
                <fieldset>
                    <h3>2. M√†n Chi·∫øu</h3>
                    <div class="row ">
                        <div class="col-md-6">
                            <label class="form-label">K√≠ch th∆∞·ªõc (Inch)</label>
                            <input class="form-control" type="number" id="screenInch" value="150" min="50" max="800"
                                oninput="NhapDuongCheo()">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">T·ª∑ l·ªá</label>
                            <select class="form-select" id="screenRatio">
                                <option value="1.7777" selected>16:9 (TV/Phim)</option>
                                <option value="2.35">2.35:1 (CinemaScope)</option>
                                <option value="2.40">2.40:1 (Widescreen)</option>
                            </select>
                        </div>
                    </div>
                    <div class="row ">
                        <div class="col-md-6">
                            <label class="form-label">Chi·ªÅu ngang m√†n (cm)</label>
                            <input class="form-control" id="NgangLL" oninput="NhapNgang()"
                                placeholder="Nh·∫≠p chi·ªÅu ngang">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Chi·ªÅu ngang ph·ªß b√¨ (cm)</label>
                            <input class="form-control bg-light" id="NgangPB" readonly placeholder="T·ª± ƒë·ªông t√≠nh">
                        </div>
                    </div>

                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label class="form-label">Chi·ªÅu cao m√†n (cm)</label>
                            <input class="form-control" id="CaoLL" oninput="NhapCao()" placeholder="Nh·∫≠p chi·ªÅu cao">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">Chi·ªÅu cao ph·ªß b√¨ (cm)</label>
                            <input class="form-control bg-light" id="CaoPB" readonly placeholder="T·ª± ƒë·ªông t√≠nh">
                        </div>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>G√≥c nh√¨n</legend>

                    <div class="row ">
                        <div class="col-md-6">
                            <label class="form-label">Kho·∫£ng c√°ch xem (cm)</label>
                            <input class="form-control bg-light" id="KhoangCach" readonly placeholder="T·ª± ƒë·ªông t√≠nh">
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">G√≥c nh√¨n (ƒë·ªô)</label>
                            <input class="form-control bg-light" id="GocNhin" type="number" value="45"
                                onchange="TinhKhoangCach()" />
                        </div>
                    </div>
                </fieldset>


                <div class="input-group" style="margin-top:20px;">
                    <label>C√°ch s√†n: <span id="val-screenBot" class="value-display">85</span> cm</label>
                    <input class="form-range" type="range" id="screenBottom" min="10" max="250" value="85">
                </div>
            </div>
            <div class="section">
                <h3>3. Gh·∫ø & B·ª•c</h3>
                <div class="input-group">
                    <label for="eyeHeight">Cao ƒë·ªô m·∫Øt: <span id="val-eyeHeight" class="value-display">115</span>
                        cm</label>
                    <input class="form-range" type="range" id="eyeHeight" min="100" max="130" value="115">
                </div>
                <div class="input-group">
                    <label>S·ªë h√†ng gh·∫ø: <span id="val-rows" class="value-display">3</span></label>
                    <input class="form-range" type="range" id="rowCount" min="1" max="10" value="3">
                </div>
                <div class="input-group">
                    <label>H√†ng ƒë·∫ßu c√°ch m√†n: <span id="val-firstRow" class="value-display">350 </span> cm</label>
                    <input class="form-range" type="range" id="firstRowDist" min="150" max="1500" value="350">
                </div>
                <div class="input-group">
                    <label>Kho·∫£ng c√°ch h√†ng: <span id="val-rowSpace" class="value-display">160</span> cm</label>
                    <input class="form-range" type="range" id="rowSpacing" min="90" max="300" value="160">
                </div>
                <div class="input-group">
                    <label>ƒê·ªô cao gi·∫≠t c·∫•p: <span id="val-riser" class="value-display">20</span> cm</label>
                    <input class="form-range" type="range" id="riserHeight" min="0" max="100" value="20">
                </div>
            </div>
        </div>
        <div class="visualization-container">
            <div class="canvas-wrapper sideview">
                <div class="canvas-header">
                    <h2 class="canvas-title pt-3 ps-3">üìê M·∫∑t c·∫Øt ngang (Side View)</h2>
                </div>
                <div class="canvas-container">

                    <canvas id="simCanvas"></canvas>
                </div>
                <div class="legend">
                    <span class="item"><span class="line-sight-bot"></span>Tia nh√¨n ƒë√°y (Check che)</span>
                    <span class="item"><span class="line-sight-top"></span>Tia nh√¨n ƒë·ªânh</span>
                    <span class="item"><span class="dot dot-red"></span>B·ªã che</span>
                    <span class="item" style="margin-left: auto;"><span class="line-dim"></span>K√≠ch th∆∞·ªõc (cm)</span>
                </div>

            </div>
            <div class="canvas-wrapper top-view">
                <div class="canvas-wrapper">
                    <div class="canvas-header">
                        <h2 class="canvas-title">üó∫Ô∏è M·∫∑t b·∫±ng (Top View)</h2>
                    </div>
                    <div class="canvas-container">
                        <canvas id="topCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <script>
        const inputs = {
            rLen: document.getElementById('roomLength'),
            rHeight: document.getElementById('roomHeight'),
            rWidth: document.getElementById('roomWidth'),
            sInch: document.getElementById('screenInch'),
            sRatio: document.getElementById('screenRatio'),
            sBot: document.getElementById('screenBottom'),
            eyeH: document.getElementById('eyeHeight'),
            rows: document.getElementById('rowCount'),
            firstRow: document.getElementById('firstRowDist'),
            rowSpace: document.getElementById('rowSpacing'),
            riser: document.getElementById('riserHeight')
        };

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const itc = 2.54;
        const PBCm = 15;

        /* ====== NH·∫¨P ƒê∆Ø·ªúNG CH√âO (INCH) ====== */
        function NhapDuongCheo() {
            const inch = parseFloat(inputs.sInch.value);
            if (isNaN(inch)) return;

            const tyle = parseFloat(inputs.sRatio.value);
            const cheoCm = inch * itc;

            const cao = Math.sqrt(cheoCm ** 2 / (tyle ** 2 + 1));
            const ngang = cao * tyle;

            HienThi(cheoCm, ngang, cao);
        }

        /* ====== NH·∫¨P CHI·ªÄU NGANG (CM) ====== */
        function NhapNgang() {
            const ngang = parseFloat(NgangLL.value);
            if (isNaN(ngang)) return;

            const tyle = parseFloat(inputs.sRatio.value);
            const cao = ngang / tyle;
            const cheoCm = Math.sqrt(ngang ** 2 + cao ** 2);

            HienThi(cheoCm, ngang, cao);
        }

        /* ====== NH·∫¨P CHI·ªÄU CAO (CM) ====== */
        function NhapCao() {
            const cao = parseFloat(CaoLL.value);
            if (isNaN(cao)) return;

            const tyle = parseFloat(inputs.sRatio.value);
            const ngang = cao * tyle;
            const cheoCm = Math.sqrt(ngang ** 2 + cao ** 2);

            HienThi(cheoCm, ngang, cao);
        }

        /* ====== HI·ªÇN TH·ªä T·∫§T C·∫¢ ====== */
        function HienThi(cheoCm, ngang, cao) {
            inputs.sInch.value = Math.round(cheoCm / itc);
            NgangLL.value = Math.round(ngang);
            CaoLL.value = Math.round(cao);

            NgangPB.value = Math.round(ngang + PBCm - 3);
            CaoPB.value = Math.round(cao + PBCm - 3);

            TinhKhoangCach();
        }

        /* ====== G√ìC NH√åN ====== */
        function TinhKhoangCach() {
            const ngang = parseFloat(NgangLL.value);
            if (isNaN(ngang)) return;

            const goc = parseFloat(GocNhin.value);
            const rad = (goc / 2) * Math.PI / 180;

            const d = (ngang / 100) / (2 * Math.tan(rad));
            KhoangCach.value = Math.round(d * 100);
        }


        // Canvas drawing functions
        function getScreenDimensions() {
            const diagInch = parseFloat(inputs.sInch.value);
            const ratio = parseFloat(inputs.sRatio.value);
            const heightInch = diagInch / Math.sqrt(1 + (ratio * ratio));
            const widthInch = heightInch * ratio;
            return { h: heightInch * 2.54, w: widthInch * 2.54 };
        }

        function updateLabels() {
            document.getElementById('val-screenBot').innerText = inputs.sBot.value;
            document.getElementById('val-eyeHeight').innerText = inputs.eyeH.value;
            document.getElementById('val-rows').innerText = inputs.rows.value;
            document.getElementById('val-firstRow').innerText = inputs.firstRow.value;
            document.getElementById('val-rowSpace').innerText = inputs.rowSpace.value;
            document.getElementById('val-riser').innerText = inputs.riser.value;
            const dims = getScreenDimensions();
        }

        // H√†m v·∫Ω ƒë∆∞·ªùng DIM (Dimension Line)
        function drawDimensionLine(ctx, x1, y1, x2, y2, text, isVertical = false, offsetText = 0) {
            ctx.save();
            ctx.strokeStyle = "#0d47a1";
            ctx.fillStyle = "#0d47a1";
            ctx.lineWidth = 1;
            ctx.font = "11px Arial";

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();


            const tickSize = 5;
            ctx.beginPath();
            if (isVertical) {
                ctx.moveTo(x1 - tickSize, y1); ctx.lineTo(x1 + tickSize, y1);
                ctx.moveTo(x2 - tickSize, y2); ctx.lineTo(x2 + tickSize, y2);
                ctx.textAlign = "right";
                ctx.fillText(text, x1 - 8 - offsetText, (y1 + y2) / 2 + 4);
            } else {
                ctx.moveTo(x1, y1 - tickSize); ctx.lineTo(x1, y1 + tickSize);
                ctx.moveTo(x2, y2 - tickSize); ctx.lineTo(x2, y2 + tickSize);
                ctx.textAlign = "center";
                ctx.fillText(text, (x1 + x2) / 2, y1 - 5 - offsetText);
            }
            ctx.stroke();
            ctx.restore();
        }

        // H√†m v·∫Ω ƒë∆∞·ªùng gi√≥ng m·ªù (Extension Line)
        function drawExtensionLine(ctx, x1, y1, x2, y2) {
            ctx.save();
            ctx.strokeStyle = "#90a4ae";
            ctx.lineWidth = 0.5;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }

        // H√†m v·∫Ω gh·∫ø Premium
        function drawPremiumChair(ctx, eyeX, floorH, toX, toY, pxPerCm) {
            const seatBackX = eyeX + 15;
            const seatFrontX = eyeX - 40;
            const seatBaseY = floorH;
            const seatHeight = 40;
            const backHeight = 105;
            const armrestHeight = 60;

            const chairColor = "#546e7a";
            const cushionColor = "#78909c";
            const armrestColor = "#455a64";

            ctx.save();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = "#37474f";

            // Ch√¢n gh·∫ø
            ctx.fillStyle = chairColor;
            ctx.beginPath();
            ctx.moveTo(toX(seatFrontX + 5), toY(seatBaseY));
            ctx.lineTo(toX(seatBackX - 5), toY(seatBaseY));
            ctx.lineTo(toX(seatBackX - 5), toY(seatBaseY + 10));
            ctx.lineTo(toX(seatFrontX + 5), toY(seatBaseY + 10));
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillRect(toX(eyeX - 5), toY(seatBaseY + 8), toX(eyeX + 5) - toX(eyeX - 5), toY(seatBaseY + seatHeight) - toY(seatBaseY + 10));

            // ƒê·ªám ng·ªìi
            ctx.fillStyle = cushionColor;
            ctx.beginPath();
            ctx.moveTo(toX(seatFrontX), toY(seatBaseY + seatHeight));
            ctx.lineTo(toX(seatBackX), toY(seatBaseY + seatHeight));
            ctx.quadraticCurveTo(toX(seatBackX + 5), toY(seatBaseY + seatHeight), toX(seatBackX + 5), toY(seatBaseY + seatHeight + 5));
            ctx.lineTo(toX(seatBackX + 5), toY(seatBaseY + seatHeight + 15));
            ctx.lineTo(toX(seatFrontX), toY(seatBaseY + seatHeight + 15));
            ctx.quadraticCurveTo(toX(seatFrontX - 5), toY(seatBaseY + seatHeight + 15), toX(seatFrontX - 5), toY(seatBaseY + seatHeight + 5));
            ctx.lineTo(toX(seatFrontX - 5), toY(seatBaseY + seatHeight));
            ctx.closePath();
            ctx.fill(); ctx.stroke();

            // T·ª±a l∆∞ng
            ctx.beginPath();
            ctx.moveTo(toX(seatBackX), toY(seatBaseY + seatHeight));
            const leanBack = 10;
            ctx.lineTo(toX(seatBackX + leanBack), toY(seatBaseY + backHeight - 20));
            ctx.quadraticCurveTo(toX(seatBackX + leanBack + 2), toY(seatBaseY + backHeight), toX(seatBackX + leanBack + 10), toY(seatBaseY + backHeight + 5));
            ctx.quadraticCurveTo(toX(seatBackX + leanBack + 18), toY(seatBaseY + backHeight), toX(seatBackX + leanBack + 20), toY(seatBaseY + backHeight - 20));
            ctx.lineTo(toX(seatBackX + 15), toY(seatBaseY + seatHeight + 5));
            ctx.closePath();
            ctx.fill(); ctx.stroke();

            // Tay v·ªãn
            ctx.fillStyle = armrestColor;
            ctx.beginPath();
            ctx.moveTo(toX(seatFrontX - 2), toY(seatBaseY + armrestHeight));
            ctx.lineTo(toX(seatBackX + 5), toY(seatBaseY + armrestHeight));
            ctx.quadraticCurveTo(toX(seatBackX + 10), toY(seatBaseY + armrestHeight), toX(seatBackX + 10), toY(seatBaseY + armrestHeight - 5));
            ctx.lineTo(toX(seatBackX + 10), toY(seatBaseY + armrestHeight - 10));
            ctx.lineTo(toX(seatFrontX - 2), toY(seatBaseY + armrestHeight - 10));
            ctx.quadraticCurveTo(toX(seatFrontX - 7), toY(seatBaseY + armrestHeight - 10), toX(seatFrontX - 7), toY(seatBaseY + armrestHeight - 5));
            ctx.lineTo(toX(seatFrontX - 7), toY(seatBaseY + armrestHeight));
            ctx.closePath();
            ctx.fill(); ctx.stroke();

            ctx.restore();
        }

        function draw() {
            updateLabels();

            const roomLen = parseInt(inputs.rLen.value);
            const roomHeight = parseInt(inputs.rHeight.value);
            const screenDims = getScreenDimensions();
            const screenH = screenDims.h;
            const screenBot = parseInt(inputs.sBot.value);
            const screenTop = screenBot + screenH;
            const eyeFromFloor = parseInt(inputs.eyeH.value);
            const headTopFromFloor = eyeFromFloor + 15;
            const rowCount = parseInt(inputs.rows.value);
            const firstRowDist = parseInt(inputs.firstRow.value);
            const rowSpace = parseInt(inputs.rowSpace.value);
            const riserH = parseInt(inputs.riser.value);

            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.parentElement.offsetHeight;

            const pL = 100, pR = 100, pT = 50, pB = 100;

            const scaleX = (canvas.width - pL - pR) / roomLen;
            const scaleY = (canvas.height - pT - pB) / roomHeight;
            const pxPerCm = Math.min(scaleX, scaleY);

            const originX = pL;
            const originY = canvas.height - pB;

            const toX = (cm) => originX + (cm * pxPerCm);
            const toY = (cm) => originY - (cm * pxPerCm);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. V·∫Ω T∆∞·ªùng Ph√≤ng & S√†n
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(toX(0), toY(roomHeight), roomLen * pxPerCm, roomHeight * pxPerCm);
            ctx.strokeStyle = "#cfd8dc"; ctx.lineWidth = 2;
            ctx.strokeRect(toX(0), toY(roomHeight), roomLen * pxPerCm, roomHeight * pxPerCm);

            // 2. M√†n H√¨nh
            ctx.fillStyle = (screenTop > roomHeight) ? "#ef5350" : "#212121";
            ctx.fillRect(toX(0), toY(screenTop), 8, (screenH * pxPerCm));

            // --- DIM: M√ÄN H√åNH (B√™n tr√°i) ---
            const dimX_Left = toX(0) - 20;
            // Dim kho·∫£ng c√°ch s√†n -> ƒë√°y m√†n
            drawDimensionLine(ctx, dimX_Left, toY(0), dimX_Left, toY(screenBot), `${screenBot} cm`, true);
            drawExtensionLine(ctx, toX(0), toY(screenBot), dimX_Left, toY(screenBot));
            // Dim chi·ªÅu cao m√†n
            drawDimensionLine(ctx, dimX_Left, toY(screenBot), dimX_Left, toY(screenTop), `${Math.round(screenH)} cm`, true);
            drawExtensionLine(ctx, toX(0), toY(screenTop), dimX_Left, toY(screenTop));

            // 3. Loop: Gh·∫ø, B·ª•c, Ng∆∞·ªùi & Dims
            let viewers = [];
            let seatBackPositions = [];
            for (let i = 0; i < rowCount; i++) seatBackPositions.push(firstRowDist + (i * rowSpace) + 15);

            const dimY_Row = toY(0) + 50;

            for (let i = 0; i < rowCount; i++) {
                const dist = firstRowDist + (i * rowSpace);
                const floorH = i * riserH;
                if (dist > roomLen - 50) continue;

                // B·ª•c
                if (floorH > 0) {
                    let riserStartX = (i === 0) ? (dist - 120) : seatBackPositions[i - 1];
                    let riserEndX = 1000;
                    if (riserEndX > roomLen) riserEndX = roomLen;
                    if (riserStartX < 0) riserStartX = 0;
                    const riserWidth = riserEndX - riserStartX;

                    if (riserWidth > 0) {
                        ctx.fillStyle = "#eceff1";
                        ctx.fillRect(toX(riserStartX), toY(floorH), riserWidth * pxPerCm, floorH * pxPerCm);
                        ctx.strokeStyle = "#cfd8dc"; ctx.lineWidth = 1; ctx.setLineDash([]);
                        ctx.strokeRect(toX(riserStartX), toY(floorH), riserWidth * pxPerCm, floorH * pxPerCm);

                        // --- DIM: CHI·ªÄU CAO B·ª§C (B√™n tr√°i b·ª•c) ---
                        const dimX_Riser = toX(riserStartX) - 15;
                        drawDimensionLine(ctx, dimX_Riser, toY(0), dimX_Riser, toY(floorH), `${floorH} cm`, true);
                        drawExtensionLine(ctx, toX(riserStartX), toY(floorH), dimX_Riser, toY(floorH));
                    }
                }

                // V·∫Ω Gh·∫ø & Ng∆∞·ªùi
                drawPremiumChair(ctx, dist, floorH, toX, toY, pxPerCm);
                const eyeX = dist;
                const eyeY = floorH + eyeFromFloor;
                const headY = floorH + headTopFromFloor;
                viewers.push({ x: eyeX, y: eyeY, headY: headY, rIndex: i });

                // Ng∆∞·ªùi
                // 1. V·∫Ω Th√¢n (N·ª≠a tr√™n Elip)
                ctx.fillStyle = "#455a64"; // M√†u √°o
                ctx.beginPath();
                // C·∫•u tr√∫c: ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle)
                ctx.ellipse(
                    toX(eyeX),       // T√¢m X: L√πi l·∫°i sau m·∫Øt
                    toY(floorH + 55),    // T√¢m Y: H·∫° th·∫•p t√¢m xu·ªëng g·∫ßn m·∫∑t gh·∫ø ƒë·ªÉ ƒë∆∞·ªùng c·∫Øt n·∫±m ƒë√∫ng ch·ªó
                    15 * pxPerCm,        // B√°n k√≠nh NGANG (Vai r·ªông ra m·ªôt ch√∫t)
                    (eyeY - floorH - 75) * pxPerCm,        // B√°n k√≠nh D·ªåC (L∆∞ng d√†i ra v√¨ ch·ªâ c√≤n n·ª≠a tr√™n)
                    Math.PI / 10,        // G√≥c nghi√™ng
                    Math.PI - 0.2,             // NG·∫ÆT: G√≥c b·∫Øt ƒë·∫ßu (180 ƒë·ªô)
                    2 * Math.PI          // NG·∫ÆT: G√≥c k·∫øt th√∫c (360 ƒë·ªô) -> Ch·ªâ v·∫Ω n·ª≠a v√≤ng cung ph√≠a tr√™n
                );
                // H√†m fill() s·∫Ω t·ª± ƒë·ªông n·ªëi ƒëi·ªÉm ƒë·∫ßu v√† ƒëi·ªÉm cu·ªëi t·∫°o th√†nh ƒë∆∞·ªùng c·∫Øt ph·∫≥ng
                ctx.fill();
                // ƒê·∫ßu  
                ctx.beginPath(); ctx.arc(toX(eyeX + 10), toY(eyeY - 5), 11 * pxPerCm, 0, Math.PI * 2); ctx.fillStyle = "#ffccbc"; ctx.fill(); ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = "#263238"; ctx.beginPath(); ctx.arc(toX(eyeX) + 2, toY(eyeY), 1.8, 0, Math.PI * 2); ctx.fill();

                // --- DIM: KHO·∫¢NG C√ÅCH GH·∫æ (D∆∞·ªõi s√†n) ---
                drawExtensionLine(ctx, toX(dist), toY(floorH), toX(dist), dimY_Row);
                if (i === 0) {
                    drawDimensionLine(ctx, toX(0), dimY_Row, toX(dist), dimY_Row, `${Math.round(dist)} cm`);
                    drawExtensionLine(ctx, toX(0), toY(0), toX(0), dimY_Row);
                } else {
                    const prevDist = firstRowDist + ((i - 1) * rowSpace);
                    drawDimensionLine(ctx, toX(prevDist), dimY_Row, toX(dist), dimY_Row, `${Math.round(rowSpace)} cm`);
                }
            }

            // 4. Sightlines (Tia nh√¨n)
            ctx.lineWidth = 1.5;
            viewers.forEach(viewer => {
                let lineBlocked = false;
                for (let j = 0; j < viewer.rIndex; j++) {
                    const prev = viewers[j];
                    const slope = (viewer.y - screenBot) / viewer.x;
                    const yAtPrev = (slope * prev.x) + screenBot;
                    if (yAtPrev < prev.headY - 2) lineBlocked = true;
                }

                // Tia nh√¨n ƒë·∫øn ƒê√ÅY
                ctx.beginPath();
                ctx.moveTo(toX(viewer.x), toY(viewer.y));
                ctx.lineTo(toX(0), toY(screenBot));
                ctx.strokeStyle = lineBlocked ? "#d50000" : "#00c853";
                ctx.setLineDash(lineBlocked ? [6, 4] : []);
                ctx.stroke();

                // Tia nh√¨n ƒë·∫øn ƒê·ªàNH
                ctx.beginPath();
                ctx.moveTo(toX(viewer.x), toY(viewer.y));
                ctx.lineTo(toX(0), toY(screenTop));
                ctx.strokeStyle = "#b3e5fc";
                ctx.setLineDash([4, 4]);
                ctx.stroke();

                // G√≥c nh√¨n
                const angleTop = Math.atan2(screenTop - viewer.y, viewer.x);
                const angleBot = Math.atan2(screenBot - viewer.y, viewer.x);
                const viewAngle = (angleTop - angleBot) * (180 / Math.PI);
                ctx.fillStyle = "#0277bd"; ctx.textAlign = "center"; ctx.font = "bold 13px sans-serif"; ctx.setLineDash([]);
                ctx.fillText(`${viewAngle.toFixed(1)}¬∞`, toX(viewer.x), toY(viewer.headY) - 25);
            });

            // 5. V·∫º DIM CHI·ªÄU CAO PH√íNG (Cu·ªëi c√πng ƒë·ªÉ ƒë√® l√™n t·∫•t c·∫£)
            const dimX_Right = toX(roomLen) + 20;
            // Xo√° m·ªôt ch√∫t n·ªÅn tr·∫Øng ph√≠a d∆∞·ªõi text dim n·∫øu c·∫ßn, nh∆∞ng v·∫Ω ƒë√® l√™n l√† ƒë·ªß
            drawDimensionLine(ctx, dimX_Right, toY(0), dimX_Right, toY(roomHeight), `${roomHeight} cm`, true);
            drawExtensionLine(ctx, toX(roomLen), toY(roomHeight), dimX_Right, toY(roomHeight));
            drawExtensionLine(ctx, toX(roomLen), toY(0), dimX_Right, toY(0));
        }


        // topview Canvas
        let masterSeatIndex = -1; // luu gh·∫ø ƒë√£ ch·ªçn
        const topCanvas = document.getElementById('topCanvas');
        const topCtx = topCanvas.getContext('2d');
        function drawTopView() {
            updateLabels();

            // --- 1. L·∫•y d·ªØ li·ªáu ---
            const roomLen = parseInt(inputs.rLen.value);    // Tr·ª•c X
            const roomWidth = parseInt(inputs.rWidth.value); // Tr·ª•c Y
            const screenDims = getScreenDimensions();
            const screenWidth = parseInt(screenDims.w);

            const rowCount = parseInt(inputs.rows.value);
            const firstRowDist = parseInt(inputs.firstRow.value);
            const rowSpace = parseInt(inputs.rowSpace.value);
            const seatSize = 50;

            // --- 2. Thi·∫øt l·∫≠p Canvas & Scale ---
            topCanvas.width = topCanvas.parentElement.offsetWidth;
            topCanvas.height = topCanvas.parentElement.offsetHeight;

            topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
            topCtx.fillStyle = "#ffffff";
            topCtx.fillRect(0, 0, topCanvas.width, topCanvas.height);

            // TƒÉng Padding ƒë·ªÉ c√≥ ch·ªó v·∫Ω c√°c ƒë∆∞·ªùng ƒëo (Tr√™n, Ph·∫£i, D∆∞·ªõi c·∫ßn nhi·ªÅu ch·ªó h∆°n)
            const padTop = 60;
            const padRight = 80;
            const padBot = 60 + (rowCount * 25); // TƒÉng l·ªÅ d∆∞·ªõi ƒë·ªông theo s·ªë h√†ng gh·∫ø
            const padLeft = 60;

            // T√≠nh v√πng v·∫Ω th·ª±c t·∫ø (Drawing Area)
            const drawW = topCanvas.width - (padLeft + padRight);
            const drawH = topCanvas.height - (padTop + padBot);

            // T√≠nh Scale
            const scaleX = drawW / roomLen;
            const scaleY = drawH / roomWidth;
            const scale = Math.min(scaleX, scaleY);

            // Offset ƒë·ªÉ cƒÉn h√¨nh v√†o v√πng an to√†n (trong padding)
            const offsetX = padLeft + (drawW - roomLen * scale) / 2;
            const offsetY = padTop + (drawH - roomWidth * scale) / 2;

            // L∆∞u params ƒë·ªÉ d√πng cho s·ª± ki·ªán click
            topCanvas.drawingParams = { scale, offsetX, offsetY, seatSize, rowSpace, firstRowDist, roomWidth };

            // H√†m chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô
            function toCX(val) { return offsetX + val * scale; }
            function toCY(val) { return offsetY + val * scale; }

            // --- H√ÄM PH·ª§ TR·ª¢: V·∫º ƒê∆Ø·ªúNG K√çCH TH∆Ø·ªöC ---
            // x1, y1: ƒêi·ªÉm b·∫Øt ƒë·∫ßu (tr√™n h√¨nh)
            // x2, y2: ƒêi·ªÉm k·∫øt th√∫c (tr√™n h√¨nh)
            // offset: Kho·∫£ng c√°ch t·ª´ h√¨nh ra ƒë∆∞·ªùng ƒëo (pixel)
            // text: N·ªôi dung hi·ªÉn th·ªã
            // isVertical: true n·∫øu ƒëo chi·ªÅu d·ªçc, false n·∫øu ƒëo chi·ªÅu ngang
            // --- H√ÄM V·∫º K√çCH TH∆Ø·ªöC CHU·∫®N (Style gi·ªëng ·∫£nh) ---
            function drawDimLine(x1, y1, x2, y2, offset, text, isVertical) {
                // C·∫•u h√¨nh Style
                const lineColor = "#4a90e2"; // M√†u xanh d∆∞∆°ng gi·ªëng ·∫£nh
                const extColor = "#b0b0b0";  // M√†u x√°m nh·∫°t cho ƒë∆∞·ªùng gi√≥ng n√©t ƒë·ª©t
                const tickSize = 5;          // ƒê·ªô d√†i g·∫°ch ch·∫Øn ƒë·∫ßu

                topCtx.font = "bold 12px Arial";
                topCtx.textAlign = "center";
                topCtx.textBaseline = "bottom"; // Ch·ªØ n·∫±m tr√™n ƒë∆∞·ªùng k·∫ª

                // T·ªça ƒë·ªô tr√™n Canvas
                const cx1 = toCX(x1); const cy1 = toCY(y1);
                const cx2 = toCX(x2); const cy2 = toCY(y2);

                let dx1, dy1, dx2, dy2, textX, textY;

                if (isVertical) {
                    // ƒêO D·ªåC (B√™n ph·∫£i)
                    dx1 = cx1 + offset; dy1 = cy1;
                    dx2 = cx2 + offset; dy2 = cy2;
                    textX = dx1 + 5;
                    textY = (dy1 + dy2) / 2;
                    topCtx.textAlign = "left";
                    topCtx.textBaseline = "middle";
                } else {
                    // ƒêO NGANG (Tr√™n ho·∫∑c D∆∞·ªõi)
                    dx1 = cx1; dy1 = cy1 + offset;
                    dx2 = cx2; dy2 = cy2 + offset;
                    textX = (dx1 + dx2) / 2;
                    textY = dy1 - 2; // C√°ch ƒë∆∞·ªùng k·∫ª 2px l√™n tr√™n
                }

                // 1. V·∫Ω ƒë∆∞·ªùng gi√≥ng n√©t ƒë·ª©t (Extension Lines - m√†u x√°m nh·∫°t)
                topCtx.beginPath();
                topCtx.setLineDash([2, 2]); // N√©t ƒë·ª©t
                topCtx.strokeStyle = extColor;
                topCtx.lineWidth = 1;
                topCtx.moveTo(cx1, cy1); topCtx.lineTo(dx1, dy1);
                topCtx.moveTo(cx2, cy2); topCtx.lineTo(dx2, dy2);
                topCtx.stroke();
                topCtx.setLineDash([]); // Reset n√©t li·ªÅn

                // 2. V·∫Ω ƒë∆∞·ªùng k√≠ch th∆∞·ªõc ch√≠nh (Dimension Line - m√†u xanh)
                topCtx.beginPath();
                topCtx.strokeStyle = lineColor;
                topCtx.lineWidth = 1.5;
                topCtx.moveTo(dx1, dy1); topCtx.lineTo(dx2, dy2);
                topCtx.stroke();

                // 3. V·∫Ω 2 ƒë·∫ßu g·∫°ch ch·∫Øn (Ticks/Caps - m√†u xanh ƒë·∫≠m)
                topCtx.beginPath();
                topCtx.lineWidth = 2;
                if (isVertical) {
                    // G·∫°ch ngang cho ƒë∆∞·ªùng ƒëo d·ªçc
                    topCtx.moveTo(dx1 - tickSize, dy1); topCtx.lineTo(dx1 + tickSize, dy1);
                    topCtx.moveTo(dx2 - tickSize, dy2); topCtx.lineTo(dx2 + tickSize, dy2);
                } else {
                    // G·∫°ch d·ªçc cho ƒë∆∞·ªùng ƒëo ngang (Gi·ªëng ·∫£nh)
                    topCtx.moveTo(dx1, dy1 - tickSize); topCtx.lineTo(dx1, dy1 + tickSize);
                    topCtx.moveTo(dx2, dy2 - tickSize); topCtx.lineTo(dx2, dy2 + tickSize);
                }
                topCtx.stroke();

                // 4. V·∫Ω ch·ªØ s·ªë ƒëo (M√†u xanh ƒë·∫≠m)
                topCtx.fillStyle = "#2c5282"; // Xanh ƒë·∫≠m h∆°n cho ch·ªØ d·ªÖ ƒë·ªçc
                topCtx.fillText(text, textX, textY);
            }

            // --- B·∫ÆT ƒê·∫¶U V·∫º ---

            // 1. V·∫Ω khung ph√≤ng
            topCtx.strokeStyle = "#333"; topCtx.lineWidth = 2;
            topCtx.strokeRect(toCX(0), toCY(0), roomLen * scale, roomWidth * scale);

            // 2. V·∫Ω M√†n h√¨nh
            const screenX = 0;
            const screenY = (roomWidth - screenWidth) / 2;
            topCtx.beginPath(); topCtx.lineWidth = 5; topCtx.strokeStyle = "#000";
            topCtx.moveTo(toCX(screenX + 5), toCY(screenY));
            topCtx.lineTo(toCX(screenX + 5), toCY(screenY + screenWidth));
            topCtx.stroke();

            // L∆∞u t·ªça ƒë·ªô m√©p m√†n h√¨nh ƒë·ªÉ v·∫Ω tia
            const screenTopEdge = { x: 0, y: screenY };
            const screenBotEdge = { x: 0, y: screenY + screenWidth };



            // --- V·∫º C√ÅC ƒê∆Ø·ªúNG ƒêO (DIMENSIONS) ---
            // A. ƒêo Chi·ªÅu D√†i Ph√≤ng (·ªû TR√äN)
            // Offset √¢m ƒë·ªÉ ƒë·∫©y l√™n tr√™n. Gi√° tr·ªã -30px so v·ªõi m√©p tr√™n ph√≤ng
            drawDimLine(0, 0, roomLen, 0, -30, "L: " + roomLen, false);

            // B. ƒêo Chi·ªÅu R·ªông Ph√≤ng (·ªû B√äN PH·∫¢I)
            // Offset d∆∞∆°ng 30px so v·ªõi m√©p ph·∫£i ph√≤ng
            drawDimLine(roomLen, 0, roomLen, roomWidth, 30, "W: " + roomWidth, true);

            // C. ƒêo Kho·∫£ng C√°ch N·ªëi Ti·∫øp (Chain Dimension - N·∫±m tr√™n 1 ƒë∆∞·ªùng th·∫≥ng)
            let prevX = 0; // ƒêi·ªÉm b·∫Øt ƒë·∫ßu l√† m√†n h√¨nh (X=0)
            const fixedDimOffset = 50; // Kho·∫£ng c√°ch c·ªë ƒë·ªãnh t·ª´ m√©p ph√≤ng xu·ªëng ƒë∆∞·ªùng ƒëo

            for (let i = 0; i < rowCount; i++) {
                const distFromScreen = firstRowDist + (i * rowSpace);
                const currentEyeX = distFromScreen + seatSize; // T√¢m gh·∫ø hi·ªán t·∫°i

                // T√≠nh ƒë·ªô d√†i ƒëo·∫°n n√†y (Kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm ƒëo)
                const segmentLength = currentEyeX - prevX;

                // V·∫Ω ƒë∆∞·ªùng ƒëo t·ª´ ƒëi·ªÉm c≈© (prevX) ƒë·∫øn ƒëi·ªÉm m·ªõi (currentEyeX)
                // Y ƒë·ªÅu l√† roomWidth (c·∫°nh ƒë√°y ph√≤ng)
                drawDimLine(prevX, roomWidth, currentEyeX, roomWidth, fixedDimOffset, segmentLength, false);

                // C·∫≠p nh·∫≠t ƒëi·ªÉm b·∫Øt ƒë·∫ßu cho v√≤ng l·∫∑p sau l√† t√¢m gh·∫ø hi·ªán t·∫°i
                prevX = currentEyeX;
            }
            // D. Do chi·ªÅu r·ªông m√†n h√¨nh (·ªû B√äN TR√ÅI)
            drawDimLine(0, 0, 0, screenY, -50, `${Math.round((roomWidth - screenWidth) / 2)}`, true);

            drawDimLine(0, screenY, 0, screenY + screenWidth, -50, `${Math.round(screenWidth)}`, true);

            // --- V·∫º GH·∫æ V√Ä TIA NH√åN---
            topCtx.textAlign = "center"; topCtx.textBaseline = "middle";
            topCtx.font = "bold 12px Arial";

            for (let i = 0; i < rowCount; i++) {
                const distFromScreen = firstRowDist + (i * rowSpace);
                const seatX = distFromScreen;
                const seatY = (roomWidth - seatSize) / 2;
                const eyeX = seatX + seatSize / 2;
                const eyeY = seatY + seatSize / 2;

                // --- 1. T√≠nh g√≥c ---
                const halfScreen = screenWidth / 2;
                const alphaRad = Math.atan(halfScreen / eyeX);
                const totalAngleDeg = (2 * alphaRad * (180 / Math.PI)).toFixed(1);

                // --- 2. V·∫Ω tia nh√¨n (N√©t ƒë·ª©t) ---
                topCtx.beginPath();
                topCtx.strokeStyle = (i === selectedSeatIndex) ? "rgba(255, 165, 0, 1)" : "rgba(0, 200, 0, 0.3)";
                topCtx.setLineDash([2, 2]);
                topCtx.lineWidth = (i === selectedSeatIndex) ? 2 : 1;
                topCtx.moveTo(toCX(eyeX), toCY(eyeY)); topCtx.lineTo(toCX(screenTopEdge.x), toCY(screenTopEdge.y));
                topCtx.moveTo(toCX(eyeX), toCY(eyeY)); topCtx.lineTo(toCX(screenBotEdge.x), toCY(screenBotEdge.y));
                topCtx.stroke();

                /// --- 3. V·∫º CHI TI·∫æT GH·∫æ ---
                topCtx.setLineDash([]); // ƒê·∫£m b·∫£o n√©t li·ªÅn

                // A. C·∫•u h√¨nh m√†u s·∫Øc & Bi·∫øn
                const cx = toCX(seatX);
                const cy = toCY(seatY);
                const s = seatSize * scale; // K√≠ch th∆∞·ªõc hi·ªÉn th·ªã th·ª±c t·∫ø
                const isSel = (i === selectedSeatIndex);

                // M√†u gh·∫ø: Ch·ªçn th√¨ Xanh ƒê·∫≠m (#003399), Kh√¥ng ch·ªçn th√¨ Tr·∫Øng (#ffffff)
                const seatFill = isSel ? "#003399" : "#ffffff";
                // M√†u vi·ªÅn: Ch·ªçn th√¨ V√†ng (#FFD700), Kh√¥ng ch·ªçn th√¨ ƒêen (#333)
                const seatStroke = isSel ? "#FFD700" : "#333333";
                // M√†u ch·ªØ: Ch·ªçn th√¨ Tr·∫Øng, Kh√¥ng ch·ªçn th√¨ ƒêen
                const textCol = isSel ? "#ffffff" : "#000000";

                topCtx.fillStyle = seatFill;
                topCtx.strokeStyle = seatStroke;
                topCtx.lineWidth = isSel ? 2 : 1;

                // B. V·∫Ω c√°c b·ªô ph·∫≠n (Gi·∫£ ƒë·ªãnh m√†n h√¨nh b√™n TR√ÅI, gh·∫ø quay m·∫∑t sang TR√ÅI)

                // 1. T·ª±a l∆∞ng (H√¨nh ch·ªØ nh·∫≠t ƒë·ª©ng ·ªü ph√≠a sau/b√™n ph·∫£i)
                // Chi·∫øm 20% chi·ªÅu r·ªông, n·∫±m ·ªü cu·ªëi √¥ (b√™n ph·∫£i)
                topCtx.fillRect(cx + s * 0.8, cy, s * 0.2, s);
                topCtx.strokeRect(cx + s * 0.8, cy, s * 0.2, s);

                // 2. Hai tay v·ªãn (H√¨nh ch·ªØ nh·∫≠t m·∫£nh ·ªü tr√™n v√† d∆∞·ªõi)
                // Tay tr√™n
                topCtx.fillRect(cx, cy, s * 0.8, s * 0.15);
                topCtx.strokeRect(cx, cy, s * 0.8, s * 0.15);
                // Tay d∆∞·ªõi
                topCtx.fillRect(cx, cy + s * 0.85, s * 0.8, s * 0.15);
                topCtx.strokeRect(cx, cy + s * 0.85, s * 0.8, s * 0.15);

                // 3. ƒê·ªám ng·ªìi (H√¨nh vu√¥ng ·ªü gi·ªØa)
                // N·∫±m l·ªçt v√†o trong: c√°ch l·ªÅ tr√°i 10%, c√°ch tr√™n 20%
                topCtx.fillRect(cx + s * 0.1, cy + s * 0.2, s * 0.7, s * 0.6);
                topCtx.strokeRect(cx + s * 0.1, cy + s * 0.2, s * 0.7, s * 0.6);

                // 4. ƒê√°nh s·ªë th·ª© t·ª± (·ªû gi·ªØa ƒë·ªám ng·ªìi)
                topCtx.fillStyle = textCol;
                topCtx.textAlign = "center";
                topCtx.textBaseline = "middle";
                // T·ª± ƒë·ªông ch·ªânh c·ª° ch·ªØ theo scale (nh∆∞ng kh√¥ng qu√° nh·ªè)
                const fontSize = Math.max(10, s * 0.4);
                topCtx.font = "bold " + fontSize + "px Arial";

                // T√¢m ch·ªØ n·∫±m gi·ªØa ph·∫ßn ƒë·ªám ng·ªìi
                topCtx.fillText(i + 1, cx + s * 0.45, cy + s * 0.5);

                // --- 4. [M·ªöI] V·∫Ω ƒë∆∞·ªùng B·ª•c N√¢ng (Riser) ---
                // V·ªã tr√≠: C·∫°nh b√™n ph·∫£i c·ªßa gh·∫ø (seatX + seatSize)
                const riserX = seatX + seatSize;

                topCtx.beginPath();
                topCtx.setLineDash([]); // ƒê·∫£m b·∫£o n√©t li·ªÅn
                topCtx.strokeStyle = "#cccccc"; // M√†u x√°m nh·∫°t t∆∞·ª£ng tr∆∞ng cho m√©p b·∫≠c thang
                topCtx.lineWidth = 1;

                // V·∫Ω t·ª´ m√©p tr√™n ph√≤ng (y=0) xu·ªëng m√©p d∆∞·ªõi ph√≤ng (y=roomWidth)
                topCtx.moveTo(toCX(riserX), toCY(0));
                topCtx.lineTo(toCX(riserX), toCY(roomWidth));
                topCtx.stroke();

                // --- 5. Hi·ªÉn th·ªã s·ªë ƒëo g√≥c ---
                const textX = eyeX - (rowSpace * 0.4);
                topCtx.fillStyle = "#000";
                topCtx.fillText(totalAngleDeg + "¬∞", toCX(textX), toCY(eyeY));
            }
        }

        // --- S·ª∞ KI·ªÜN CLICK V√ÄO CANVAS ---
        topCanvas.addEventListener('mousedown', function (e) {
            const params = topCanvas.drawingParams;
            if (!params) return;

            // 1. L·∫•y t·ªça ƒë·ªô chu·ªôt tr√™n Canvas
            const rect = topCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // 2. Chuy·ªÉn ƒë·ªïi ng∆∞·ª£c t·ª´ pixel Canvas v·ªÅ t·ªça ƒë·ªô th·ª±c t·∫ø (Real World Coordinates)
            const realX = (clickX - params.offsetX) / params.scale;
            const realY = (clickY - params.offsetY) / params.scale;

            // 3. Ki·ªÉm tra xem c√≥ click tr√∫ng gh·∫ø n√†o kh√¥ng
            const rowCount = parseInt(inputs.rows.value);
            let clickedIndex = -1;

            for (let i = 0; i < rowCount; i++) {
                // T√≠nh v·ªã tr√≠ th·ª±c c·ªßa gh·∫ø th·ª© i
                const seatRealX = params.firstRowDist + (i * params.rowSpace);
                const seatRealY = (params.roomWidth - params.seatSize) / 2;

                // Check va ch·∫°m (Hit test)
                if (realX >= seatRealX && realX <= seatRealX + params.seatSize &&
                    realY >= seatRealY && realY <= seatRealY + params.seatSize) {
                    clickedIndex = i;
                    break;
                }
            }

            // 4. X·ª≠ l√Ω khi ch·ªçn gh·∫ø
            if (clickedIndex !== -1) {
                selectedSeatIndex = clickedIndex;
                drawTopView(); // V·∫Ω l·∫°i ƒë·ªÉ highlight gh·∫ø v·ª´a ch·ªçn

                // T√≠nh g√≥c hi·ªán t·∫°i ƒë·ªÉ hi·ªÉn th·ªã trong prompt
                const screenDims = getScreenDimensions();
                const halfScreen = screenDims.w / 2;
                const eyeX = (params.firstRowDist + (clickedIndex * params.rowSpace)) + params.seatSize / 2;
                const currentAngle = (2 * Math.atan(halfScreen / eyeX) * (180 / Math.PI)).toFixed(1);

                // --- T√çNH NƒÇNG CH·ªàNH G√ìC ---
                // S·ª≠ d·ª•ng setTimeout ƒë·ªÉ UI v·∫Ω xong highlight r·ªìi m·ªõi hi·ªán prompt
                setTimeout(() => {
                    const newAngleStr = prompt(
                        `B·∫°n ƒëang ch·ªçn gh·∫ø h√†ng ${clickedIndex + 1}.\n` +
                        `G√≥c nh√¨n hi·ªán t·∫°i: ${currentAngle}¬∞\n` +
                        `Nh·∫≠p g√≥c mong mu·ªën (gh·∫ø s·∫Ω t·ª± di chuy·ªÉn):`,
                        currentAngle
                    );

                    if (newAngleStr !== null) {
                        const newAngle = parseFloat(newAngleStr);
                        if (!isNaN(newAngle) && newAngle > 0 && newAngle < 180) {
                            adjustLayoutByAngle(clickedIndex, newAngle);
                        } else {
                            alert("G√≥c nh·∫≠p kh√¥ng h·ª£p l·ªá!");
                        }
                    }
                }, 10);
            } else {
                // Click ra ngo√†i th√¨ b·ªè ch·ªçn
                selectedSeatIndex = -1;
                drawTopView();
            }
        });

        // --- H√ÄM T√çNH TO√ÅN D·ªäCH CHUY·ªÇN GH·∫æ ---
        function adjustLayoutByAngle(seatIndex, targetAngleDeg) {
            const screenDims = getScreenDimensions();
            const screenWidth = parseInt(screenDims.w);
            const rowSpace = parseInt(inputs.rowSpace.value);
            const seatSize = 50; // K√≠ch th∆∞·ªõc gh·∫ø c·ªë ƒë·ªãnh trong code v·∫Ω

            // 1. T√≠nh kho·∫£ng c√°ch c·∫ßn thi·∫øt t·ª´ M·∫Øt ƒë·∫øn M√†n h√¨nh ƒë·ªÉ ƒë·∫°t g√≥c targetAngle
            // C√¥ng th·ª©c: Distance = (ScreenW / 2) / tan(Angle / 2)
            const halfScreen = screenWidth / 2;
            const targetAngleRad = targetAngleDeg * (Math.PI / 180);
            const requiredEyeDist = halfScreen / Math.tan(targetAngleRad / 2);

            // 2. T√≠nh v·ªã tr√≠ h√†ng ƒë·∫ßu ti√™n (First Row) m·ªõi
            // Hi·ªán t·∫°i: EyeDist = FirstRow + (Index * RowSpace) + (SeatSize/2)
            // => NewFirstRow = RequiredEyeDist - (Index * RowSpace) - (SeatSize/2)

            let newFirstRow = requiredEyeDist - (seatIndex * rowSpace) - (seatSize / 2);

            // L√†m tr√≤n
            newFirstRow = Math.round(newFirstRow);

            // 3. C·∫≠p nh·∫≠t Input v√† V·∫Ω l·∫°i
            if (newFirstRow < 0) {
                alert("G√≥c n√†y qu√° l·ªõn! Gh·∫ø s·∫Ω b·ªã ƒë·∫©y ra kh·ªèi ph√≤ng v·ªÅ ph√≠a m√†n h√¨nh.");
            }

            // C·∫≠p nh·∫≠t gi√° tr·ªã v√†o √¥ input c·ªßa b·∫°n
            inputs.firstRow.value = newFirstRow;

            // G·ªçi h√†m c·∫≠p nh·∫≠t UI/V·∫Ω l·∫°i (gi·∫£ s·ª≠ b·∫°n c√≥ h√†m update() t·ªïng ho·∫∑c g·ªçi drawTopView())
            drawTopView();
            // N·∫øu b·∫°n c√≥ h√†m updateLabels() hay listeners input th√¨ trigger n√≥
            if (inputs.firstRow.oninput) inputs.firstRow.oninput();
        }


        Object.values(inputs).forEach(el => el.addEventListener('input', draw));
        Object.values(inputs).forEach(el => el.addEventListener('input', drawTopView));
        window.addEventListener('resize', draw);
        window.addEventListener('resize', drawTopView);
        NhapDuongCheo();
        draw();
        drawTopView();

    </script>
</body>

</html>